#  Glue together tables with foreign keys

## Model 1: N relationships with foreign keys

Implementing relationships with foreign keys

* A foreign key (FK) points to the primary key (PK) of another table
* Domain of FK must be equal to domain of PK
* Each value of FK must exist in PK of the other table (FK constraint or "referential integrity")
* FKs are not actual keys

### Specifying foreign keys

```

CREATETABLE manufacturers ( 
    name varchar(255) PRIMARY KEY);

INSERT INTO manufacturers 
VALUES ('Ford'), ('VW'), ('GM');
CREATE TABLE cars ( 
    model varchar(255) PRIMARY KEY, 
    manufacturer_name varchar(255) REFERENCES manufacturers (name));

INSERT INTO cars VALUES ('Ranger', 'Ford'), ('Beetle', 'VW');

```

```
-- Throws an error!
INSERT INTO cars VALUES ('Tundra', 'Toyota');
```

Trying to enter models with manufacturers that are not yet stored in the "manufacturers" table won't be possible, thanks to the foreign key constraint.

### Specifying foreign keys to existing tables
```
ALTER TABLE a 
ADD CONSTRAINT a_fkey FOREIGN KEY (b_id) REFERENCES b (id);
```

## REFERENCE a table with a FOREIGN KEY

```
ALTER TABLE a 
ADD CONSTRAINT a_fkey FOREIGN KEY (b_id) REFERENCES b (id);
```

Table a should now refer to table b, via b_id, which points to id. a_fkey is, as usual, a constraint name you can choose on your own.

-- Rename the university_shortname column
ALTER TABLE professors
RENAME COLUMN university_shortname TO university_id;

-- Add a foreign key on professors referencing universities
ALTER table professors 
add constraint professors_fkey FOREIGN KEY (university_id) REFERENCES universities (id);

## Explore foreign key constraints

```
-- Try to insert a new professor
INSERT INTO professors (firstname, lastname, university_id)
VALUES ('Albert', 'Einstein', 'MIT');
```

inserting a professor with non-existing university IDs violates the foreign key constraint you've just added. This also makes sure that all universities are spelled equally – adding to data consistency.
```
-- Try to insert a new professor
INSERT INTO professors (firstname, lastname, university_id)
VALUES ('Albert', 'Einstein', 'UZH');
```


## JOIN tables linked by a foreign key

* JOIN professors with universities on professors.university_id = universities.id, i.e., retain all records where the foreign key of professors is equal to the primary key of universities.

* Filter for university_city = 'Zurich'.

```
-- Select all professors working for universities in the city of Zurich
SELECT professors.lastname, universities.id, universities.university_city
FROM professors
LEFT JOIN universities
ON professors.university_id = universities.id
where universities.university_city = 'Zurich';
```



## Model more complex relationships

How to implement N:M-relationships

* Create a table
* Add foreign keys for every connected table
* Add additional attributes

```
CREATETABLE affiliations ( 
    professor_id integer REFERENCES professors (id), 
    organization_id varchar(256) REFERENCES organizations (id),
    functionvarchar(256));
```
* No primary key!
* Possible PK = {professor_id, organization_id, function}

## Add foreign keys to the "affiliations" table

* Add a professor_id column with integer data type to affiliations, and declare it to be a foreign key that references the id column in professors.

* Rename the organization column in affiliations to organization_id.

* Add a foreign key constraint on organization_id so that it references the id column in organizations.

```
-- Add a professor_id column
ALTER TABLE affiliations
ADD COLUMN professor_id integer REFERENCES professors (id);

-- Rename the organization column to organization_id
ALTER TABLE affiliations
RENAME organization TO organization_id;

-- Add a foreign key on organization_id
ALTER TABLE affiliations
ADD CONSTRAINT affiliations_organization_fkey foreign key (organization_id) references organizations (id);
```

## Populate the "professor_id" column

Here's a way to update columns of a table based on values in another table:

```
UPDATE table_a
SET column_to_update = table_b.column_to_update_from
FROM table_b
WHERE condition1 AND condition2 AND ...;
```

This query does the following:

1. For each row in table_a, find the corresponding row in table_b where condition1, condition2, etc., are met.
2. Set the value of column_to_update to the value of column_to_update_from (from that corresponding row).


* Update the professor_id column with the corresponding value of the id column in professors.
"Corresponding" means rows in professors where the firstname and lastname are identical to the ones in affiliations.

```
-- Set professor_id to professors.id where firstname, lastname correspond to rows in professors
UPDATE affiliations
SET professor_id = professors.id
FROM professors
WHERE affiliations.firstname = professors.firstname AND affiliations.lastname = professors.lastname;
```

## Drop "firstname" and "lastname"

The firstname and lastname columns of affiliations were used to establish a link to the professors table in the last exercise – so the appropriate professor IDs could be copied over. This only worked because there is exactly one corresponding professor for each row in affiliations. In other words: {firstname, lastname} is a candidate key of professors – a unique combination of columns.

Because professors are referenced by professor_id now, the firstname and lastname columns are no longer needed, so it's time to drop them.

```
-- Drop the firstname column
alter table affiliations
DROP column firstname;

-- Drop the lastname column
alter table affiliations
DROP column lastname;
```

## Referential integrity

* A record referencing another table must refer to an existing record in that table
* Specified between two tables
* Enforced through foreign keys


### Referential integrity violations

Referential integrity from table A to table B is violated...
* ...if a record in table B that is referenced from a record in table A is deleted
* ....if a record in table A referencing a non-existing record from table B is inserted.
* Foreign keys prevent violations!


### Dealing with violations

```
CREATE TABLE a ( 
    id integer PRIMARY KEY, 
    column_a varchar(64),  
    ..., 
    b_id integer REFERENCES b (id) ON DELETE NO ACTION);

CREATE TABLE a ( 
    id integer PRIMARY KEY, 
    column_a varchar(64),  
    ..., 
    b_id integer REFERENCES b (id) ON DELETE CASCADE);

```
* ON DELETE...
    * ...NO ACTION: Throw an error
    * ...CASCADE: Delete all referencing records
    * ...RESTRICT: Throw an error
    * ...SET NULL: Set the referencing column to NULL
    * ...SET DEFAULT: Set the referencing column to its default value


## Change the referential integrity behavior of a key
Altering a key constraint doesn't work with ALTER COLUMN. Instead, you have to DROP the key constraint and then ADD a new one with a different ON DELETE behavior.

For deleting constraints, though, you need to know their name. This information is also stored in information_schema.

* Have a look at the existing foreign key constraints by querying table_constraints in information_schema.

```
-- Identify the correct constraint name
SELECT constraint_name, table_name, constraint_type
FROM information_schema.table_constraints
WHERE constraint_type = 'FOREIGN KEY';
```
Add a new foreign key to affiliations that CASCADEs deletion if a referenced record is deleted from organizations. Name it affiliations_organization_id_fkey

```
-- Add a new foreign key constraint from affiliations to organizations which cascades deletion
ALTER TABLE affiliations
ADD CONSTRAINT affiliations_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES organizations (id) ON DELETE CASCADE;
```

```
-- Delete an organization 
DELETE FROM organizations 
WHERE id = 'CUREM';

-- Check that no more affiliations with this organization exist
SELECT * FROM affiliations
WHERE organization_id = 'CUREM';
```


## Count affiliations per university
* Count the number of total affiliations by university.
* Sort the result by that count, in descending order.

```
-- Count the total number of affiliations per university
SELECT COUNT(*), professors.university_id 
FROM affiliations
JOIN professors
ON affiliations.professor_id = professors.id
-- Group by the university ids of professors
GROUP BY professors.university_id 
ORDER BY count DESC;
```


## Join all the tables together

Join all tables in the database (starting with affiliations, professors, organizations, and universities) and look at the result.

```
-- Join all tables
SELECT *
FROM affiliations
JOIN professors
ON affiliations.professor_id = professors.id
JOIN organizations
ON affiliations.organization_id = organizations.id
JOIN universities
ON professors.university_id = universities.id;
```

Now group the result by organization sector, professor, and university city.
Count the resulting number of rows.

```
SELECT COUNT(*), organizations.organization_sector, 
professors.id, universities.university_city
FROM affiliations
JOIN professors
ON affiliations.professor_id = professors.id
JOIN organizations
ON affiliations.organization_id = organizations.id
JOIN universities
ON professors.university_id = universities.id
GROUP BY organizations.organization_sector, 
professors.id, universities.university_city;
```
Only retain rows with "Media & communication" as organization sector, and sort the table by count, in descending order.

```
-- Filter the table and sort it
SELECT COUNT(*), organizations.organization_sector, 
professors.id, universities.university_city
FROM affiliations
JOIN professors
ON affiliations.professor_id = professors.id
JOIN organizations
ON affiliations.organization_id = organizations.id
JOIN universities
ON professors.university_id = universities.id
WHERE organizations.organization_sector = 'Media & communication'
GROUP BY organizations.organization_sector, 
professors.id, universities.university_city
ORDER BY count DESC;
```