#  Enforce data conssistency with attribute constraints

Integrity constraints
1. Attribute constraints.- data types on columns
2. Key constraints.- Primary keys
3. Referential integrity constraints.- Enforced through foreign keys


Why constraints?
1. Give data structure
2. Help with consistency
3. Data Quality
4. Enforcing is difficult, but PostgreSQL helps

## Conforming with data types

A fictional database table that only holds three records. The columns have the data types date, integer, and text, respectively.

```
CREATE TABLE transactions (
 transaction_date date, 
 amount integer,
 fee text
)
```

The transaction_date accepts date values. According to the PostgreSQL documentation, it accepts values in the form of YYYY-MM-DD, DD/MM/YY.

```
-- Let's add a record to the table
INSERT INTO transactions (transaction_date, amount, fee) 
VALUES ('2018-24-09', 5454, '30');

-- Doublecheck the contents
SELECT *
FROM transactions;
```
Error: date/time field value out of range: "2018-24-09"

```
-- Let's add a record to the table
INSERT INTO transactions (transaction_date, amount, fee) 
VALUES ('2018-09-24', 5454, '30');

-- Doublecheck the contents
SELECT *
FROM transactions;
```

Data types provide certain restrictions on how data can be entered into a table.

## Type of CASTs

If you know that a certain column stores numbers as text, you can cast the column to a numeric form, i.e. to integer.

```
SELECT CAST(some_column AS integer)
FROM table;
```

```
-- Calculate the net amount as amount + fee
SELECT transaction_date, amount + CAST(fee AS integer) AS net_amount 
FROM transactions;
```

## Working with data types
* text, varchar, char, boolean, date, time, timestamp, numeric, integer.

```
CREATE TABLE students 
(   ssn integer,  
    name varchar(64),  
    dob date,  
    average_grade numeric(3, 2), -- e.g. 5.54 
    tuition_paid boolean
);

```

Alter types after table creation
```
ALTERTABLE students
ALTER COLUMN name TYPE varchar(128);
```
```
ALTER TABLE students
ALTER COLUMN average_grade
TYPE integer-- Turns 5.54 into 6, not 5, before type conversion
USING ROUND(average_grade);
```

## Change types with ALTER Column

```
ALTER TABLE table_name
ALTER COLUMN column_name
TYPE varchar(10)
```

Have a look at the distinct university_shortname values in the professors

```
-- Select the university_shortname column
SELECT distinct(university_shortname) 
FROM professors;
```

Now specify a fixed-length character type with the correct length for university_shortname.

```
-- Specify the correct fixed-length character type
ALTER TABLE professors
ALTER COLUMN university_shortname
TYPE char(3);
```

Change the type of the firstname column to varchar(64).

```
-- Change the type of firstname
ALTER TABLE professors
ALTER COLUMN firstname
TYPE varchar(64);
```

## Converting types USING a function

If you don't want to reserve too much space for a certain varchar column, you can truncate the values before converting its type.

```
ALTER TABLE table_name
ALTER COLUMN column_name
TYPE varchar(x)
USING SUBSTRING(column_name FROM 1 FOR x)
```

You should read it like this: Because you want to reserve only x characters for column_name, you have to retain a SUBSTRING of every value, i.e. the first x characters of it, and throw away the rest. This way, the values will fit the varchar(x) requirement.

```
-- Convert the values in firstname to a max. of 16 characters
ALTER TABLE professors 
ALTER COLUMN firstname 
TYPE varchar(16)
USING SUBSTRING(firstname from 1 for 16)
```

## The not-null constraint
* Disallow NULL values in a certain column
* Must hold true for the current state
* Must hold true for any future state

```
CREATE TABLE students 
( ssn integernotnull, 
lastname varchar(64) notnull, home_phone integer, 
office_phone integer);
```

### How to add or remove a not-null constraint

After the table has been created...
```
ALTER TABLE students 
ALTER COLUMN home_phone 
SET NOT NULL;
```

```
ALTER TABLE students 
ALTER COLUMN ssn DROP NOT NULL;
```

## The unique constraint
* Disallow duplicate values in a column
* Must hold true for the current state
* Must hold true for any future state

## Adding unique constraints
```
CREATE TABLE table_name ( column_name UNIQUE);
```
```
ALTER TABLE table_name ADD CONSTRAINT some_name UNIQUE(column_name);
```

## Disallow NULL values with SET NOT NULL

```
-- Disallow NULL values in firstname
ALTER TABLE professors 
ALTER COLUMN firstname SET NOT NULL;
```


```
-- Disallow NULL values in lastname
ALTER TABLE professors 
ALTER COLUMN lastname 
SET NOT NULL;
```

## Make your columns UNIQUE with ADD CONSTRAINT

Add a unique constraint to the university_shortname column in universities. Give it the name university_shortname_unq

```
-- Make universities.university_shortname unique
ALTER TABLE universities
ADD CONSTRAINT university_shortname_unq UNIQUE(university_shortname);
```
```
-- Make organizations.organization unique

ALTER TABLE organizations
ADD CONSTRAINT organization_unq UNIQUE(organization);
```